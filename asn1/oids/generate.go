//go:build ignore
// +build ignore

// This program generates a Go source file containing a pre-parsed OID registry.
// Usage with go:generate:
//
//   //go:generate go run generate.go
//
// This will read dumpasn1.cfg and generate oids_generated.go

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"log"
	"os"
	"strings"
	"text/template"
	"time"
)

const tmpl = `// Code generated by go generate; DO NOT EDIT.
// Generated at {{.Timestamp}}
// Source: dumpasn1.cfg

package oids

// DefaultRegistry contains all OIDs parsed from dumpasn1.cfg at build time.
var DefaultRegistry = &Registry{
	entries: map[string]*OIDInfo{
{{- range .Entries}}
		"{{.OID}}": {
			OID:         "{{.OID}}",
			Description: {{printf "%q" .Description}},
			{{- if .Comment}}
			Comment:     {{printf "%q" .Comment}},
			{{- end}}
			{{- if .Warning}}
			Warning:     true,
			{{- end}}
		},
{{- end}}
	},
}

// Lookup retrieves OID information from the default registry.
func Lookup(oid string) (*OIDInfo, bool) {
	return DefaultRegistry.Lookup(oid)
}

// LookupDescription returns the description for an OID from the default registry.
func LookupDescription(oid string) string {
	return DefaultRegistry.LookupDescription(oid)
}
`

type OIDInfo struct {
	OID         string
	Description string
	Comment     string
	Warning     bool
}

type templateData struct {
	Timestamp string
	Entries   []*OIDInfo
}

func main() {
	if err := run(); err != nil {
		log.Fatal(err)
	}
}

func run() error {
	// Read and parse dumpasn1.cfg
	entries, err := parseConfigFile("dumpasn1.cfg")
	if err != nil {
		return fmt.Errorf("failed to parse config: %w", err)
	}

	// Generate Go source
	data := templateData{
		Timestamp: time.Now().Format(time.RFC3339),
		Entries:   entries,
	}

	t := template.Must(template.New("oids").Parse(tmpl))

	var buf bytes.Buffer
	if err := t.Execute(&buf, data); err != nil {
		return fmt.Errorf("template execution failed: %w", err)
	}

	// Format the generated code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// Write unformatted code to help debug
		os.WriteFile("oids_generated.go.debug", buf.Bytes(), 0644)
		return fmt.Errorf("formatting failed: %w", err)
	}

	// Write to file
	if err := os.WriteFile("oids_generated.go", formatted, 0644); err != nil {
		return fmt.Errorf("write failed: %w", err)
	}

	fmt.Printf("Generated oids_generated.go with %d OID entries\n", len(entries))
	return nil
}

func parseConfigFile(filename string) ([]*OIDInfo, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		return nil, err
	}

	var entries []*OIDInfo
	var current *OIDInfo

	lines := strings.Split(string(data), "\n")
	for lineNum, line := range lines {
		// Skip blank lines and comments
		trimmed := strings.TrimSpace(line)
		if trimmed == "" || strings.HasPrefix(trimmed, "#") {
			continue
		}

		// Parse attribute line
		parts := strings.SplitN(line, "=", 2)

		// Check if this is a Warning flag (no '=' sign)
		if len(parts) == 1 {
			attr := strings.TrimSpace(parts[0])
			if attr == "Warning" {
				if current == nil {
					return nil, fmt.Errorf("line %d: Warning without OID", lineNum+1)
				}
				current.Warning = true
				continue
			}
			return nil, fmt.Errorf("line %d: invalid format", lineNum+1)
		}

		attr := strings.TrimSpace(parts[0])
		value := strings.TrimSpace(parts[1])

		switch attr {
		case "OID":
			// Save previous entry if exists
			if current != nil {
				if err := validateEntry(current); err != nil {
					return nil, fmt.Errorf("line %d: %w", lineNum+1, err)
				}
				entries = append(entries, current)
			}
			current = &OIDInfo{OID: value}

		case "Description":
			if current == nil {
				return nil, fmt.Errorf("line %d: Description without OID", lineNum+1)
			}
			current.Description = value

		case "Comment":
			if current == nil {
				return nil, fmt.Errorf("line %d: Comment without OID", lineNum+1)
			}
			current.Comment = value
		}
	}

	// Don't forget the last entry
	if current != nil {
		if err := validateEntry(current); err != nil {
			return nil, fmt.Errorf("end of file: %w", err)
		}
		entries = append(entries, current)
	}

	return entries, nil
}

func validateEntry(info *OIDInfo) error {
	if info.OID == "" {
		return fmt.Errorf("OID cannot be empty")
	}
	if info.Description == "" {
		return fmt.Errorf("Description required for OID %s", info.OID)
	}
	return nil
}
